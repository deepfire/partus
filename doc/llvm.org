#+startup: hidestars odd


* General info

  - % :: local identifier
  - @ :: global identifier

* Modules
*** Module contents:
***** Functions
******* Definition
********* "define"
********* [ linkage type ]
********* [ visibility style ]
********* [ calling convention ]
********* [ unnamed_addr ]
********* <result type>
********* [ parameter attribute ]
********* @<function name>
********* (argument list (optional parameter attributes))
*********** Parameter attributes
************* zeroext
************* signext
************* inreg
************* byval
************* sret
************* noalias
************* nocapture
************* nest
********* [ function attributes ]

          - address_safety :: This attribute indicates that the /address safety analysis/ is
                              enabled for this function.
          - alignstack(<n>) :: This attribute indicates that, when emitting the prologue and
               epilogue, the backend should forcibly align the stack pointer. Specify the
               desired alignment, which must be a power of two, in parentheses.
          - alwaysinline :: This attribute indicates that the inliner should attempt to inline
                            this function into callers whenever possible, ignoring any active
                            inlining size threshold for this caller.
          - nonlazybind :: This attribute suppresses lazy symbol binding for the function. This
                           may make calls to the function faster, at the cost of extra program
                           startup time if the function is not called during program startup.
          - inlinehint :: This attribute indicates that the source code contained a hint that
                          inlining this function is desirable (such as the "inline" keyword in
                          C/C++). It is just a hint; it imposes no requirements on the inliner.
          - naked :: This attribute disables prologue / epilogue emission for the
                     function. This can have very system-specific consequences.
          - noimplicitfloat :: This attributes disables implicit floating point instructions.
          - noinline :: This attribute indicates that the inliner should never inline this
                        function in any situation. This attribute may not be used together with
                        the alwaysinline attribute.
          - noredzone :: This attribute indicates that the code generator should not use a red
                         zone, even if the target-specific ABI normally permits it.
          - noreturn :: This function attribute indicates that the function never returns
                        normally. This produces undefined behavior at runtime if the function
                        ever does dynamically return.
          - nounwind :: This function attribute indicates that the function never returns with
                        an unwind or exceptional control flow. If the function does unwind, its
                        runtime behavior is undefined.
          - optsize :: This attribute suggests that optimization passes and code generator
                       passes make choices that keep the code size of this function low, and
                       otherwise do optimizations specifically to reduce code size.
          - readnone :: This attribute indicates that the function computes its result (or
                        decides to unwind an exception) based strictly on its arguments,
                        without dereferencing any pointer arguments or otherwise accessing any
                        mutable state (e.g. memory, control registers, etc) visible to caller
                        functions. It does not write through any pointer arguments (including
                        byval arguments) and never changes any state visible to callers. This
                        means that it cannot unwind exceptions by calling the C++ exception
                        throwing methods.
          - readonly :: This attribute indicates that the function does not write through any
                        pointer arguments (including byval arguments) or otherwise modify any
                        state (e.g. memory, control registers, etc) visible to caller
                        functions. It may dereference pointer arguments and read state that may
                        be set in the caller. A readonly function always returns the same value
                        (or unwinds an exception identically) when called with the same set of
                        arguments and global state. It cannot unwind an exception by calling
                        the C++ exception throwing methods.
          - returns_twice :: This attribute indicates that this function can return twice. The
                             C setjmp is an example of such a function. The compiler disables
                             some optimizations (like tail calls) in the caller of these
                             functions.
          - ssp :: This attribute indicates that the function should emit a stack smashing
                   protector. It is in the form of a "canary"—a random value placed on the
                   stack before the local variables that's checked upon return from the
                   function to see if it has been overwritten. A heuristic is used to determine
                   if a function needs stack protectors or not.

                   If a function that has an ssp attribute is inlined into a function that
                   doesn't have an ssp attribute, then the resulting function will have an ssp
                   attribute.
          - sspreq :: This attribute indicates that the function should always emit a stack
                      smashing protector. This overrides the ssp function attribute.

                      If a function that has an sspreq attribute is inlined into a function
                      that doesn't have an sspreq attribute or which has an ssp attribute, then
                      the resulting function will have an sspreq attribute.
          - uwtable :: This attribute indicates that the ABI being targeted requires that an
                       unwind table entry be produce for this function even if we can show that
                       no exceptions passes by it. This is normally the case for the ELF x86-64
                       abi, but it can be disabled for some compilation units.
********* [ section "name" ]
********* [ align N ]
********* [ GC name ]
********* "{" list of basic blocks "}"
*********** [ label -> symtab entry ]
*********** list of instructions
*********** terminator insn (branch or return)
********* NOTE: first BB has no PHI nodes and no predecessors
******* Declaration
********* "declare"
********* [ linkage type ]
********* [ visibility style ]
********* [ calling convention ]
********* [ unnamed_addr ]
********* <result type>
********* [ parameter attribute ]
********* @<function name>
********* (argument list (no parameter attributes))
********* [ align N ]
********* [ GC name ]
***** Global vars: compile-time allocated memory regions
******* TLSness:
********* localdynamic
********* initialexec
********* localexec
******* Constantness
******* unnamed_addr-ness -- "the address is not significant, only the content"

        ..can be merged with other constants if they have the same initializer.

******* numbered address space
******* named section
******* alignment -- chaotic good, lawful evil, true neutral..
***** Symtab entries
******* Aliases
********* Aliasees: function, gvar, alias, bitcast of global value
********* Structure
*********** @<name>
*********** "alias"
*********** [ linkage ]
*********** [ visibility ]
*********** <aliasee type>
*********** @<aliasee>
******* Named metadata
***** Module level inline assembly
******* module asm "..."
***** Data layout
******* target datalayout "..."
*** Function and Globalvar Linkage Types

    - private :: Global values with "private" linkage are only directly accessible by objects
                 in the current module. In particular, linking code into a module with an
                 private global value may cause the private to be renamed as necessary to avoid
                 collisions. Because the symbol is private to the module, all references can be
                 updated. This doesn't show up in any symbol table in the object file.
    - linker_private :: Similar to private, but the symbol is passed through the assembler and
                        evaluated by the linker. Unlike normal strong symbols, they are removed
                        by the linker from the final linked image (executable or dynamic
                        library).
    - linker_private_weak :: Similar to "linker_private", but the symbol is weak. Note that
         linker_private_weak symbols are subject to coalescing by the linker. The symbols are
         removed by the linker from the final linked image (executable or dynamic library).
    - internal :: Similar to private, but the value shows as a local symbol (STB_LOCAL in the
                  case of ELF) in the object file. This corresponds to the notion of the
                  'static' keyword in C.
    - available_externally :: Globals with "available_externally" linkage are never emitted
         into the object file corresponding to the LLVM module. They exist to allow inlining
         and other optimizations to take place given knowledge of the definition of the global,
         which is known to be somewhere outside the module. Globals with available_externally
         linkage are allowed to be discarded at will, and are otherwise the same as
         linkonce_odr. This linkage type is only allowed on definitions, not declarations.
    - linkonce :: Globals with "linkonce" linkage are merged with other globals of the same
                  name when linkage occurs. This can be used to implement some forms of inline
                  functions, templates, or other code which must be generated in each
                  translation unit that uses it, but where the body may be overridden with a
                  more definitive definition later. Unreferenced linkonce globals are allowed
                  to be discarded. Note that linkonce linkage does not actually allow the
                  optimizer to inline the body of this function into callers because it doesn't
                  know if this definition of the function is the definitive definition within
                  the program or whether it will be overridden by a stronger definition. To
                  enable inlining and other optimizations, use "linkonce_odr" linkage.
    - weak :: "weak" linkage has the same merging semantics as linkonce linkage, except that
              unreferenced globals with weak linkage may not be discarded. This is used for
              globals that are declared "weak" in C source code.
    - common :: "common" linkage is most similar to "weak" linkage, but they are used for
                tentative definitions in C, such as "int X;" at global scope. Symbols with
                "common" linkage are merged in the same way as weak symbols, and they may not
                be deleted if unreferenced. common symbols may not have an explicit section,
                must have a zero initializer, and may not be marked 'constant'. Functions and
                aliases may not have common linkage.
    - appending :: "appending" linkage may only be applied to global variables of pointer to
                   array type. When two global variables with appending linkage are linked
                   together, the two global arrays are appended together. This is the LLVM,
                   typesafe, equivalent of having the system linker append together "sections"
                   with identical names when .o files are linked.
    - extern_weak :: The semantics of this linkage follow the ELF object file model: the symbol
                     is weak until linked, if not linked, the symbol becomes null instead of
                     being an undefined reference.
    - linkonce_odrweak_odr :: Some languages allow differing globals to be merged, such as two
         functions with different semantics. Other languages, such as C++, ensure that only
         equivalent globals are ever merged (the "one definition rule" — "ODR"). Such languages
         can use the linkonce_odr and weak_odr linkage types to indicate that the global will
         only be merged with equivalent globals. These linkage types are otherwise the same as
         their non-odr versions.
    - linkonce_odr_auto_hide :: Similar to "linkonce_odr", but nothing in the translation unit
         takes the address of this definition. For instance, functions that had an inline
         definition, but the compiler decided not to inline it. linkonce_odr_auto_hide may have
         only default visibility. The symbols are removed by the linker from the final linked
         image (executable or dynamic library).
    - external :: If none of the above identifiers are used, the global is externally visible,
                  meaning that it participates in linkage and can be used to resolve external
                  symbol references.

*** Function Calling Conventions
***** ccc
***** fastcc
***** coldcc
***** cc 10
*** Function and Globalvar Visibility Styles

    - default :: On targets that use the ELF object file format, default visibility means that
                 the declaration is visible to other modules and, in shared libraries, means
                 that the declared entity may be overridden. On Darwin, default visibility
                 means that the declaration is visible to other modules. Default visibility
                 corresponds to "external linkage" in the language.
    - hidden :: Two declarations of an object with hidden visibility refer to the same object
                if they are in the same shared object. Usually, hidden visibility indicates
                that the symbol will not be placed into the dynamic symbol table, so no other
                module (executable or shared library) can reference it directly.
    - protected :: On ELF, protected visibility indicates that the symbol will be placed in the
                   dynamic symbol table, but that references within the defining module will
                   bind to the local symbol. That is, the symbol cannot be overridden by
                   another module.

*** Local Named Types: aliases for structural types

    LLVM IR allows you to specify name aliases for certain types. This can make it easier to
    read the IR and make the IR more condensed (particularly when recursive types are
    involved). An example of a name specification is:

      %mytype = type { %mytype*, i32 }

    You may give a name to any type except "void". Type name aliases may be used anywhere a
    type is expected with the syntax "%mytype".

* Pointer aliasing rules
  - Any memory access must be done through a pointer value associated with an address range of
    the memory access, otherwise the behavior is undefined.
  - Pointer values are associated with address ranges according to the following rules:
    - A pointer value is associated with the addresses associated with any value it is based on.
    - An address of a global variable is associated with the address range of the variable's storage.
    - The result value of an allocation instruction is associated with the address range of the
      allocated storage.
    - A null pointer in the default address-space is associated with no address.
    - An integer constant other than zero or a pointer value returned from a function not
      defined within LLVM may be associated with address ranges allocated through mechanisms
      other than those provided by LLVM. Such ranges shall not overlap with any ranges of
      addresses allocated by mechanisms provided by LLVM.
    - Or, in short:
      - AddrAss(ptr) = AddrAss(Base(ptr))
      - AddrAss(Addr(gvar)) = StorageRange(gvar)
      - AddrAss(AllocationInsn) = StorageRange(AllocationInsn)
      - AddrAss(NullPtr) = None
      - + non-Null constant addresses and external allocator handling rules
  - A pointer value is based on another pointer value according to the following rules:
    - A pointer value formed from a getelementptr operation is based on the first operand of the getelementptr.
    - The result value of a bitcast is based on the operand of the bitcast.
    - A pointer value formed by an inttoptr is based on all pointer values that contribute (directly or indirectly) to the computation of the pointer's value.
    - The "based on" relationship is transitive.
    - Or, in short:
      - Base(Getelementptr(x, ...)) = x
      - Base(Bitcast(x)) = x
      - Base(Inttoptr(x)) = all y_i, such that x = f(y_0, ..., y_k) and Type(y_i) = ptr
      - x = Base(y) and y = Base(z) -> x = Base(z)
  - LLVM IR does not associate types with memory.
* Volatile memory accesses

  Certain memory accesses, such as loads, stores, and llvm.memcpys may be marked volatile. The
  optimizers must not change the number of volatile operations or change their order of
  execution relative to other volatile operations. The optimizers may change the order of
  volatile operations relative to non-volatile operations. This is not Java's "volatile" and
  has no cross-thread synchronization behavior.

* Memory Model for Concurrent Operations -- [[file://home/deepfire/src/partus/doc/LangRef.html:memmodel][LLVM Assembly Language Reference Manual]]
* Type system
*** first class :: the only insn results
***** integer         :prim
******* i<x>
***** floating point  :prim
******* half, float, double, x86_fp80, fp128, ppc_fp128
***** label           :prim
***** metadata        :prim
***** pointer         :derived
***** vector          :derived
***** array           :derived :aggregate
***** structure       :derived :aggregate
*** primitive
***** integer         :first-class
***** floating point  :first-class
***** label           :first-class
***** metadata        :first-class
***** void
***** x86mmx
*** derived: can contain primitive (except metadata) or derived
***** pointer         :first-class

      The pointer type is used to specify memory locations. Pointers are commonly used to
      reference objects in memory.

      Pointer types may have an optional address space attribute defining the numbered address
      space where the pointed-to object resides. The default address space is number zero. The
      semantics of non-zero address spaces are target-specific.

      Note that LLVM does not permit pointers to void (void*) nor does it permit pointers to
      labels (label*). Use i8* instead.

******* <type> *
***** vector          :first-class

      A vector type is a simple derived type that represents a vector of elements. Vector types
      are used when multiple primitive data are operated in parallel using a single instruction
      (SIMD). A vector type requires a size (number of elements) and an underlying primitive
      data type. Vector types are considered first class.

******* < <# elements> x <elementtype> >

        The number of elements is a constant integer value larger than 0; elementtype may be
        any integer or floating point type, or a pointer to these types. Vectors of size zero
        are not allowed.

***** array           :first-class :aggregate

      The array type is a very simple derived type that arranges elements sequentially in
      memory. The array type requires a size (number of elements) and an underlying data type.

      There is no restriction on indexing beyond the end of the array implied by a static type
      (though there are restrictions on indexing beyond the bounds of an allocated object in
      some cases). This means that single-dimension 'variable sized array' addressing can be
      implemented in LLVM with a zero length array type. An implementation of 'pascal style
      arrays' in LLVM could use the type "{ i32, [0 x float]}", for example.

******* [<# elements> x <elementtype>]

        The number of elements is a constant integer value; elementtype may be any type with a size.

***** structure       :first-class :aggregate

      The structure type is used to represent a collection of data members together in
      memory. The elements of a structure may be any type that has a size.

      Structures in memory are accessed using 'load' and 'store' by getting a pointer to a
      field with the 'getelementptr' instruction. Structures in registers are accessed using
      the 'extractvalue' and 'insertvalue' instructions.

      Structures may optionally be "packed" structures, which indicate that the alignment of
      the struct is one byte, and that there is no padding between the elements. In non-packed
      structs, padding between field types is inserted as defined by the DataLayout string in
      the module, which is required to match what the underlying code generator expects.

      Structures can either be "literal" or "identified". A literal structure is defined inline
      with other types (e.g. {i32, i32}*) whereas identified types are always defined at the
      top level with a name. Literal types are uniqued by their contents and can never be
      recursive or opaque since there is no way to write one. Identified types can be
      recursive, can be opaqued, and are never uniqued.

******* %T1 = type { <type list> }     ; Identified normal struct type
******* %T2 = type <{ <type list> }>   ; Identified packed struct type

***** function

      The function type can be thought of as a function signature. It consists of a return type
      and a list of formal parameter types. The return type of a function type is a first class
      type or a void type.

******* <returntype> (<parameter list> [, ...])

        ...where '<parameter list>' is a comma-separated list of type specifiers. Optionally,
        the parameter list may include a type ..., which indicates that the function takes a
        variable number of arguments. Variable argument functions can access their arguments
        with the variable argument handling intrinsic functions. '<returntype>' is any type
        except label.

***** opaque (structure)

      Opaque structure types are used to represent named structure types that do not have a
      body specified. This corresponds (for example) to the C notion of a forward declared
      structure.

******* %X = type opaque
* Constants
*** Simple constants
***** Boolean :: false:0, true:1 -- i1
***** Integer
***** Floating point
***** Null pointer :: null: pointer
*** Complex constants
***** Structure

      Structure constants are represented with notation similar to structure type definitions
      (a comma separated list of elements, surrounded by braces ({})). For example: 

        "{ i32 4, float 17.0, i32* @G }",
      
      where "@G" is declared as "@G = external global i32". Structure constants must have
      structure type, and the number and types of elements must match those specified by the
      type.

***** Array

      Array constants are represented with notation similar to array type definitions (a comma
      separated list of elements, surrounded by square brackets ([])). For example:

        "[ i32 42, i32 11, i32 74 ]".

      Array constants must have array type, and the number and types of elements must match
      those specified by the type.

***** Vector

      Vector constants are represented with notation similar to vector type definitions (a
      comma separated list of elements, surrounded by less-than/greater-than's (<>)). For
      example:

        "< i32 42, i32 11, i32 74, i32 100 >".
      
      Vector constants must have vector type, and the number and types of elements must match
      those specified by the type.

***** Zero initialisation

      The string 'zeroinitializer' can be used to zero initialize a value to zero of any type,
      including scalar and aggregate types. This is often used to avoid having to print large
      zero initializers (e.g. for large arrays) and is always exactly equivalent to using
      explicit zero initializers.

***** Metadata

      A metadata node is a structure-like constant with metadata type. For example: 

        "metadata !{ i32 0, metadata !"test" }".
        
      Unlike other constants that are meant to be interpreted as part of the instruction
      stream, metadata is a place to attach additional information such as debug info.

*** Global var and function addresses

    The addresses of global variables and functions are always implicitly valid (link-time)
    constants. These constants are explicitly referenced when the identifier for the global is
    used and always have pointer type.

*** Undefined values

    The string 'undef' can be used anywhere a constant is expected, and indicates that the user
    of the value may receive an unspecified bit-pattern. Undefined values may be of any type
    (other than 'label' or 'void') and be used anywhere a constant is permitted.

    Undefined values are useful because they indicate to the compiler that the program is well
    defined no matter what value is used. This gives the compiler more freedom to optimize.

*** Poison values

    Poison values are similar to undef values, however they also represent the fact that an
    instruction or constant expression which cannot evoke side effects has nevertheless
    detected a condition which results in undefined behavior.

    There is currently no way of representing a poison value in the IR; they only exist when
    produced by operations such as add with the nsw flag.

    Poison value behavior is defined in terms of value dependence:

    - Values other than phi nodes depend on their operands.
    - Phi nodes depend on the operand corresponding to their dynamic predecessor basic block.
    - Function arguments depend on the corresponding actual argument values in the dynamic
      callers of their functions.
    - Call instructions depend on the ret instructions that dynamically transfer control back
      to them.
    - Invoke instructions depend on the ret, resume, or exception-throwing call instructions
      that dynamically transfer control back to them.
    - Non-volatile loads and stores depend on the most recent stores to all of the referenced
      memory addresses, following the order in the IR (including loads and stores implied by
      intrinsics such as @llvm.memcpy.)
    - An instruction with externally visible side effects depends on the most recent preceding
      instruction with externally visible side effects, following the order in the IR. (This
      includes volatile operations.)
    - An instruction control-depends on a terminator instruction if the terminator instruction
      has multiple successors and the instruction is always executed when control transfers to
      one of the successors, and may not be executed when control is transferred to another.
    - Additionally, an instruction also control-depends on a terminator instruction if the set
      of instructions it otherwise depends on would be different if the terminator had
      transferred control to a different successor.
    - Dependence is transitive.

    Poison Values have the same behavior as undef values, with the additional affect that any
    instruction which has a dependence on a poison value has undefined behavior.

*** Addresses of basic blocks
***** blockaddress(@function, %block)

      The 'blockaddress' constant computes the address of the specified basic block in the
      specified function, and always has an i8* type. Taking the address of the entry block is
      illegal.

      This value only has defined behavior when used as an operand to the 'indirectbr'
      instruction, or for comparisons against null. Pointer equality tests between labels
      addresses results in undefined behavior — though, again, comparison against null is ok,
      and no label is equal to the null pointer. This may be passed around as an opaque pointer
      sized value as long as the bits are not inspected. This allows ptrtoint and arithmetic to
      be performed on these values so long as the original value is reconstituted before the
      indirectbr instruction.

      Finally, some targets may provide defined semantics when using the value as the operand
      to an inline assembly, but that is target specific.

*** Constant expressions

    Constant expressions are used to allow expressions involving other constants to be used as
    constants. Constant expressions may be of any first class type and may involve any LLVM
    operation that does not have side effects (e.g. load and call are not supported). The
    following is the syntax for constant expressions:

***** Truncation/extension
******* trunc (CST to TYPE)

        Truncate a constant to another type. The bit size of CST must be larger than the bit size
        of TYPE. Both types must be integers.

******* zext (CST to TYPE)

        Zero extend a constant to another type. The bit size of CST must be smaller than the bit
        size of TYPE. Both types must be integers.

******* sext (CST to TYPE)

        Sign extend a constant to another type. The bit size of CST must be smaller than the bit
        size of TYPE. Both types must be integers.

******* fptrunc (CST to TYPE)

        Truncate a floating point constant to another floating point type. The size of CST must
        be larger than the size of TYPE. Both types must be floating point.

******* fpext (CST to TYPE)

        Floating point extend a constant to another type. The size of CST must be smaller or
        equal to the size of TYPE. Both types must be floating point.

***** Float <-> integer
******* fptoui (CST to TYPE)

        Convert a floating point constant to the corresponding unsigned integer constant. TYPE
        must be a scalar or vector integer type. CST must be of scalar or vector floating point
        type. Both CST and TYPE must be scalars, or vectors of the same number of elements. If
        the value won't fit in the integer type, the results are undefined.

******* fptosi (CST to TYPE)

        Convert a floating point constant to the corresponding signed integer constant. TYPE must
        be a scalar or vector integer type. CST must be of scalar or vector floating point
        type. Both CST and TYPE must be scalars, or vectors of the same number of elements. If
        the value won't fit in the integer type, the results are undefined.

******* uitofp (CST to TYPE)

        Convert an unsigned integer constant to the corresponding floating point constant. TYPE
        must be a scalar or vector floating point type. CST must be of scalar or vector integer
        type. Both CST and TYPE must be scalars, or vectors of the same number of elements. If
        the value won't fit in the floating point type, the results are undefined.

******* sitofp (CST to TYPE)

        Convert a signed integer constant to the corresponding floating point constant. TYPE must
        be a scalar or vector floating point type. CST must be of scalar or vector integer
        type. Both CST and TYPE must be scalars, or vectors of the same number of elements. If
        the value won't fit in the floating point type, the results are undefined.

***** Pointer <-> integer
******* ptrtoint (CST to TYPE)

        Convert a pointer typed constant to the corresponding integer constant TYPE must be an
        integer type. CST must be of pointer type. The CST value is zero extended, truncated, or
        unchanged to make it fit in TYPE.

******* inttoptr (CST to TYPE)

        Convert an integer constant to a pointer constant. TYPE must be a pointer type. CST must
        be of integer type. The CST value is zero extended, truncated, or unchanged to make it
        fit in a pointer size. This one is really dangerous!

***** Generic casting
******* bitcast (CST to TYPE)

        Convert a constant, CST, to another TYPE. The constraints of the operands are the same as
        those for the bitcast instruction.

***** Address operation
******* getelementptr [inbounds] (CSTPTR, IDX0, IDX1, ...)

        Perform the getelementptr operation on constants. As with the getelementptr instruction,
        the index list may have zero or more indexes, which are required to make sense for the
        type of "CSTPTR".

***** Conditional expression
******* select (COND, VAL1, VAL2)

        Perform the select operation on constants.

***** Comparison
******* icmp COND (VAL1, VAL2)

        Performs the icmp operation on constants.

******* fcmp COND (VAL1, VAL2)

        Performs the fcmp operation on constants.

***** Vector
******* extractelement (VAL, IDX)

        Perform the extractelement operation on constants.

******* insertelement (VAL, ELT, IDX)

        Perform the insertelement operation on constants.

******* shufflevector (VEC1, VEC2, IDXMASK)

        Perform the shufflevector operation on constants.

***** Array
******* extractvalue (VAL, IDX0, IDX1, ...)

        Perform the extractvalue operation on constants. The index list is interpreted in a
        similar manner as indices in a 'getelementptr' operation. At least one index value must
        be specified.

******* insertvalue (VAL, ELT, IDX0, IDX1, ...)

        Perform the insertvalue operation on constants. The index list is interpreted in a
        similar manner as indices in a 'getelementptr' operation. At least one index value must
        be specified.

***** Binary
******* binary-or-bitwise-binary-OPCODE (LHS, RHS)

        Perform the specified operation of the LHS and RHS constants. OPCODE may be any of the
        binary or bitwise binary operations. The constraints on operands are the same as those
        for the corresponding instruction (e.g. no bitwise operations on floating point values
        are allowed).

* Other values
*** Inline assembler expressions

    Inline assembler expressions may only be used as the callee operand of a call or an invoke
    instruction.

*** Metadata nodes and metadata strings

    LLVM IR allows metadata to be attached to instructions in the program that can convey extra
    information about the code to the optimizers and code generator. One example application of
    metadata is source-level debug information. There are two metadata primitives: strings and
    nodes. All metadata has the metadata type and is identified in syntax by a preceding
    exclamation point ('!').

    A metadata string is a string surrounded by double quotes. It can contain any character by
    escaping non-printable characters with "\xx" where "xx" is the two digit hex code. For
    example: "!"test\00"".

    Metadata nodes are represented with notation similar to structure constants (a comma
    separated list of elements, surrounded by braces and preceded by an exclamation
    point). Metadata nodes can have any values as their operand.

    A named metadata is a collection of metadata nodes, which can be looked up in the module
    symbol table. For example:

      !foo =  metadata !{!4, !3}

    Metadata can be used as function arguments. Here llvm.dbg.value function is using two
    metadata arguments:

      call void @llvm.dbg.value(metadata !24, i64 0, metadata !25)

    Metadata can be attached with an instruction. Here metadata !21 is attached to the add
    instruction using the !dbg identifier:

      %indvar.next = add i64 %indvar, 1, !dbg !21

***** tbaa

      In LLVM IR, memory does not have types, so LLVM's own type system is not suitable for
      doing TBAA. Instead, metadata is added to the IR to describe a type system of a higher
      level language. This can be used to implement typical C/C++ TBAA, but it can also be used
      to implement custom alias analysis behavior for other languages.

***** tbaa.struct

      The llvm.memcpy is often used to implement aggregate assignment operations in C and
      similar languages, however it is defined to copy a contiguous region of memory, which is
      more than strictly necessary for aggregate types which contain holes due to
      padding. Also, it doesn't contain any TBAA information about the fields of the aggregate.

      !tbaa.struct metadata can describe which memory subregions in a memcpy are padding and
       what the TBAA tags of the struct are.

***** fpmath

      fpmath metadata may be attached to any instruction of floating point type. It can be used
      to express the maximum acceptable error in the result of that instruction, in ULPs, thus
      potentially allowing the compiler to use a more efficient but less accurate method of
      computing it.

***** range

      range metadata may be attached only to loads of integer types. It expresses the possible
      ranges the loaded value is in. The ranges are represented with a flattened list of
      integers. The loaded value is known to be in the union of the ranges defined by each
      consecutive pair. Each pair has the following properties:

        - The type must match the type loaded by the instruction.
        - The pair a,b represents the range [a,b).
        - Both a and b are constants.
        - The range is allowed to wrap.
        - The range should not represent the full or empty set. That is, a!=b.

      In addition, the pairs must be in signed order of the lower bound and they must be
      non-contiguous.

* "llvm.module.flags" metadata :: list of triplets
*** tripet structure
***** behaviour flag: error, warning, require, override
***** unique ID
***** value
* Intrinsic global vars
*** llvm.used

    The @llvm.used global is an array with i8* element type which has appending linkage. This
    array contains a list of pointers to global variables and functions which may optionally
    have a pointer cast formed of bitcast or getelementptr.

    For example, a legal use of it is:

      @X = global i8 4
      @Y = global i32 123

      @llvm.used = appending global [2 x i8*] [
         i8* @X,
         i8* bitcast (i32* @Y to i8*)
      ], section "llvm.metadata"

    If a global variable appears in the @llvm.used list, then the compiler, assembler, and
    linker are required to treat the symbol as if there is a reference to the global that it
    cannot see. For example, if a variable has internal linkage and no references other than
    that from the @llvm.used list, it cannot be deleted. This is commonly used to represent
    references from inline asms and other things the compiler cannot "see", and corresponds to
    "attribute((used))" in GNU C.

    On some targets, the code generator must emit a directive to the assembler or object file
    to prevent the assembler and linker from molesting the symbol.

*** llvm.compiler.used

    The @llvm.compiler.used directive is the same as the @llvm.used directive, except that it
    only prevents the compiler from touching the symbol. On targets that support it, this
    allows an intelligent linker to optimize references to the symbol without being impeded as
    it would be by @llvm.used.

    This is a rare construct that should only be used in rare circumstances, and should not be
    exposed to source languages.

*** llvm.global_ctors

      %0 = type { i32, void ()* }
      @llvm.global_ctors = appending global [1 x %0] [%0 { i32 65535, void ()* @ctor }]

    The @llvm.global_ctors array contains a list of constructor functions and associated
    priorities. The functions referenced by this array will be called in ascending order of
    priority (i.e. lowest first) when the module is loaded. The order of functions with the
    same priority is not defined.

*** llvm.global_dtors

      %0 = type { i32, void ()* }
      @llvm.global_dtors = appending global [1 x %0] [%0 { i32 65535, void ()* @dtor }]

    The @llvm.global_dtors array contains a list of destructor functions and associated
    priorities. The functions referenced by this array will be called in descending order of
    priority (i.e. highest first) when the module is loaded. The order of functions with the
    same priority is not defined.

* Instructions
*** Terminators
***** ret <type> <value> | ret void

      The 'ret' instruction is used to return control flow (and optionally a value) from a
      function back to the caller.

      There are two forms of the 'ret' instruction: one that returns a value and then causes
      control flow, and one that just causes control flow to occur.

      The 'ret' instruction optionally accepts a single argument, the return value. The type of
      the return value must be a 'first class' type.

      A function is not well formed if it it has a non-void return type and contains a 'ret'
      instruction with no return value or a return value with a type that does not match its
      type, or if it has a void return type and contains a 'ret' instruction with a return
      value.

      When the 'ret' instruction is executed, control flow returns back to the calling
      function's context. If the caller is a "call" instruction, execution continues at the
      instruction after the call. If the caller was an "invoke" instruction, execution
      continues at the beginning of the "normal" destination block. If the instruction returns
      a value, that value shall set the call or invoke instruction's return value.

***** br i1 <cond>, label <iftrue>, label <iffalse> | br <label>

      The 'br' instruction is used to cause control flow to transfer to a different basic block
      in the current function. There are two forms of this instruction, corresponding to a
      conditional branch and an unconditional branch.

      The conditional branch form of the 'br' instruction takes a single 'i1' value and two
      'label' values. The unconditional form of the 'br' instruction takes a single 'label'
      value as a target.

      Upon execution of a conditional 'br' instruction, the 'i1' argument is evaluated. If the
      value is true, control flows to the 'iftrue' label argument. If "cond" is false, control
      flows to the 'iffalse' label argument.

***** switch <intty> <value>, label <defaultdest> [ <intty> <val>, label <dest> ]

      The 'switch' instruction is used to transfer control flow to one of several different
      places. It is a generalization of the 'br' instruction, allowing a branch to occur to one
      of many possible destinations.

      The 'switch' instruction uses three parameters: an integer comparison value 'value', a
      default 'label' destination, and an array of pairs of comparison value constants and
      'label's. The table is not allowed to contain duplicate constant entries.

      The switch instruction specifies a table of values and destinations. When the 'switch'
      instruction is executed, this table is searched for the given value. If the value is
      found, control flow is transferred to the corresponding destination; otherwise, control
      flow is transferred to the default destination.

***** indirectbr <somety>* <address>, [ label <dest1>, label <dest2>, ... ]

      The 'indirectbr' instruction implements an indirect branch to a label within the current
      function, whose address is specified by "address". Address must be derived from a
      blockaddress constant.

      The 'address' argument is the address of the label to jump to. The rest of the arguments
      indicate the full set of possible destinations that the address may point to. Blocks are
      allowed to occur multiple times in the destination list, though this isn't particularly
      useful.

      This destination list is required so that dataflow analysis has an accurate understanding
      of the CFG.

      Control transfers to the block specified in the address argument. All possible
      destination blocks must be listed in the label list, otherwise this instruction has
      undefined behavior. This implies that jumps to labels defined in other functions have
      undefined behavior as well.

***** <result> = invoke [cconv] [ret attrs] <ptr to function ty> <function ptr val> (<function args>) [fn attrs] to label <normal label> unwind label <exception label>

      The 'invoke' instruction causes control to transfer to a specified function, with the
      possibility of control flow transfer to either the 'normal' label or the 'exception'
      label. If the callee function returns with the "ret" instruction, control flow will
      return to the "normal" label. If the callee (or any indirect callees) returns via the
      "resume" instruction or other exception handling mechanism, control is interrupted and
      continued at the dynamically nearest "exception" label.

      The 'exception' label is a landing pad for the exception. As such, 'exception' label is
      required to have the "landingpad" instruction, which contains the information about the
      behavior of the program after unwinding happens, as its first non-PHI instruction. The
      restrictions on the "landingpad" instruction's tightly couples it to the "invoke"
      instruction, so that the important information contained within the "landingpad"
      instruction can't be lost through normal code motion.

      This instruction requires several arguments:

        - The optional *cconv* marker indicates which calling convention the call should
          use. If none is specified, the call defaults to using C calling conventions.
        - The optional *Parameter Attributes* list for return values. Only 'zeroext', 'signext',
          and 'inreg' attributes are valid here.
        - *ptr to function ty*: shall be the signature of the pointer to function value being
          invoked. In most cases, this is a direct function invocation, but indirect invokes
          are just as possible, branching off an arbitrary pointer to function value.
        - *function ptr val*: An LLVM value containing a pointer to a function to be invoked.
        - *function args*: argument list whose types match the function signature argument
          types and parameter attributes. All arguments must be of first class type. If the
          function signature indicates the function accepts a variable number of arguments, the
          extra arguments can be specified.
        - *normal label*: the label reached when the called function executes a 'ret'
          instruction.
        - *exception label*: the label reached when a callee returns via the resume instruction
          or other exception handling mechanism.
        - The optional *function attributes* list. Only 'noreturn', 'nounwind', 'readonly' and
          'readnone' attributes are valid here.

      This instruction is designed to operate as a standard 'call' instruction in most
      regards. The primary difference is that it establishes an association with a label, which
      is used by the runtime library to unwind the stack.

      This instruction is used in languages with destructors to ensure that proper cleanup is
      performed in the case of either a longjmp or a thrown exception. Additionally, this is
      important for implementation of 'catch' clauses in high-level languages that support
      them.

      For the purposes of the SSA form, the definition of the value returned by the 'invoke'
      instruction is deemed to occur on the edge from the current block to the "normal"
      label. If the callee unwinds then no return value is available.

***** resume <type> <value>

      The 'resume' instruction is a terminator instruction that has no successors.

      The 'resume' instruction requires one argument, which must have the same type as the
      result of any 'landingpad' instruction in the same function.

      The 'resume' instruction resumes propagation of an existing (in-flight) exception whose
      unwinding was interrupted with a landingpad instruction.

***** unreachable
*** Binary                                                                           -> {ty}:result
***** <result> = add, sub, mul [nuw] [nsw] <ty> <op1>, <op2>

      The 'add' instruction returns the sum of its two operands.

      The two arguments to the 'add' instruction must be integer or vector of integer
      values. Both arguments must have identical types.

      The value produced is the integer sum of the two operands.

      If the sum has unsigned overflow, the result returned is the mathematical result modulo
      2n, where n is the bit width of the result.

      Because LLVM integers use a two's complement representation, this instruction is
      appropriate for both signed and unsigned integers.

      nuw and nsw stand for "No Unsigned Wrap" and "No Signed Wrap", respectively. If the nuw
      and/or nsw keywords are present, the result value of the add is a poison value if
      unsigned and/or signed overflow, respectively, occurs.

***** <result> = udiv, sdiv [exact] <ty> <op1>, <op2>

      The 'udiv' instruction returns the quotient of its two operands.

      The two arguments to the 'udiv' instruction must be integer or vector of integer
      values. Both arguments must have identical types.

      The value produced is the unsigned integer quotient of the two operands.

      Note that unsigned integer division and signed integer division are distinct operations;
      for signed integer division, use 'sdiv'.

      Division by zero leads to undefined behavior.

      If the exact keyword is present, the result value of the udiv is a poison value if %op1
      is not a multiple of %op2 (as such, "((a udiv exact b) mul b) == a").

***** <result> = urem, srem <ty> <op1>, <op2>

      The 'urem' instruction returns the remainder from the unsigned division of its two
      arguments.

      The two arguments to the 'urem' instruction must be integer or vector of integer
      values. Both arguments must have identical types.

      This instruction returns the unsigned integer remainder of a division. This instruction
      always performs an unsigned division to get the remainder.

      Note that unsigned integer remainder and signed integer remainder are distinct
      operations; for signed integer remainder, use 'srem'.

      Taking the remainder of a division by zero leads to undefined behavior.

***** <result> = fadd, fsub, fmul, fdiv, frem <ty> <op1>, <op2>
*** Bitwise binary                                                                   -> {ty}:result
***** <result> = shl [nuw] [nsw] <ty> <op1>, <op2>
***** <result> = lshr, ashr [exact] <ty> <op1>, <op2>
***** <result> = and, or, xor <ty> <op1>, <op2>
*** Vector
***** <result> = extractelement <n x <ty>> <val>, i32 <idx>                          -> <ty>

      The 'extractelement' instruction extracts a single scalar element from a vector at a
      specified index.

      The first operand of an 'extractelement' instruction is a value of vector type. The
      second operand is an index indicating the position from which to extract the element. The
      index may be a variable.

      The result is a scalar of the same type as the element type of val. Its value is the
      value at position idx of val. If idx exceeds the length of val, the results are
      undefined.

***** <result> = insertelement <n x <ty>> <val>, <ty> <elt>, i32 <idx>               -> <n x <ty>>

      The 'insertelement' instruction inserts a scalar element into a vector at a specified
      index.

      The first operand of an 'insertelement' instruction is a value of vector type. The second
      operand is a scalar value whose type must equal the element type of the first
      operand. The third operand is an index indicating the position at which to insert the
      value. The index may be a variable.

      The result is a vector of the same type as val. Its element values are those of val
      except at position idx, where it gets the value elt. If idx exceeds the length of val,
      the results are undefined.

***** <result> = shufflevector <n x <ty>> <v1>, <n x <ty>> <v2>, <m x i32> <mask>    -> <m x <ty>>
*** Aggregate
***** <result> = extractvalue <aggregate type> <val>, <idx>{, <idx>}*

      The 'extractvalue' instruction extracts the value of a member field from an aggregate
      value.

      The first operand of an 'extractvalue' instruction is a value of struct or array
      type. The operands are constant indices to specify which value to extract in a similar
      manner as indices in a 'getelementptr' instruction.

      The major differences to getelementptr indexing are:

        - Since the value being indexed is not a pointer, the first index is omitted and assumed to be zero.
        - At least one index must be specified.
        - Not only struct indices but also array indices must be in bounds.

      The result is the value at the position in the aggregate specified by the index operands.

***** <result> = insertvalue <aggregate type> <val>, <ty> <elt>, <idx>{, <idx>}*     -> <aggregate type>

      The 'insertvalue' instruction inserts a value into a member field in an aggregate value.

      The first operand of an 'insertvalue' instruction is a value of struct or array type. The
      second operand is a first-class value to insert. The following operands are constant
      indices indicating the position at which to insert the value in a similar manner as
      indices in a 'extractvalue' instruction. The value to insert must have the same type as
      the value identified by the indices.

      The result is an aggregate of the same type as val. Its value is that of val except that
      the value at the position specified by the indices is that of elt.

*** Memory
***** <result> = alloca <type>[, <ty> <NumElements>][, align <alignment>]            -> {type*}:result

      The 'alloca' instruction allocates memory on the stack frame of the currently executing
      function, to be automatically released when this function returns to its caller. The
      object is always allocated in the generic address space (address space zero).

      The 'alloca' instruction allocates sizeof(<type>)*NumElements bytes of memory on the
      runtime stack, returning a pointer of the appropriate type to the program. If
      "NumElements" is specified, it is the number of elements allocated, otherwise
      "NumElements" is defaulted to be one. If a constant alignment is specified, the value
      result of the allocation is guaranteed to be aligned to at least that boundary. If not
      specified, or if zero, the target can choose to align the allocation on any convenient
      boundary compatible with the type.

      'type' may be any sized type.

      Memory is allocated; a pointer is returned. The operation is undefined if there is
      insufficient stack space for the allocation. 'alloca'd memory is automatically released
      when the function returns. The 'alloca' instruction is commonly used to represent
      automatic variables that must have an address available. When the function returns
      (either with the ret or resume instructions), the memory is reclaimed. Allocating zero
      bytes is legal, but the result is undefined. The order in which memory is allocated (ie.,
      which way the stack grows) is not specified.

***** load

        <result> = load [volatile] <ty>* <pointer>[, align <alignment>][, !nontemporal !<index>][, !invariant.load !<index>]
        <result> = load atomic [volatile] <ty>* <pointer> [singlethread] <ordering>, align <alignment>
        !<index> = !{ i32 1 }

      The 'load' instruction is used to read from memory.

      The argument to the 'load' instruction specifies the memory address from which to
      load. The pointer must point to a first class type. If the load is marked as volatile,
      then the optimizer is not allowed to modify the number or order of execution of this load
      with other volatile operations.

      If the load is marked as atomic, it takes an extra ordering and optional singlethread
      argument. The release and acq_rel orderings are not valid on load instructions. Atomic
      loads produce defined results when they may see multiple atomic stores. The type of the
      pointee must be an integer type whose bit width is a power of two greater than or equal
      to eight and less than or equal to a target-specific size limit. align must be explicitly
      specified on atomic loads, and the load has undefined behavior if the alignment is not
      set to a value which is at least the size in bytes of the pointee. !nontemporal does not
      have any defined semantics for atomic loads.

      The optional constant align argument specifies the alignment of the operation (that is,
      the alignment of the memory address). A value of 0 or an omitted align argument means
      that the operation has the abi alignment for the target. It is the responsibility of the
      code emitter to ensure that the alignment information is correct. Overestimating the
      alignment results in undefined behavior. Underestimating the alignment may produce less
      efficient code. An alignment of 1 is always safe.

      The optional !nontemporal metadata must reference a single metatadata name <index>
      corresponding to a metadata node with one i32 entry of value 1. The existence of the
      !nontemporal metatadata on the instruction tells the optimizer and code generator that
      this load is not expected to be reused in the cache. The code generator may select
      special instructions to save cache bandwidth, such as the MOVNT instruction on x86.

      The optional !invariant.load metadata must reference a single metatadata name <index>
      corresponding to a metadata node with no entries. The existence of the !invariant.load
      metatadata on the instruction tells the optimizer and code generator that this load
      address points to memory which does not change value during program execution. The
      optimizer may then move this load around, for example, by hoisting it out of loops using
      loop invariant code motion.

      The location of memory pointed to is loaded. If the value being loaded is of scalar type
      then the number of bytes read does not exceed the minimum number of bytes needed to hold
      all bits of the type. For example, loading an i24 reads at most three bytes. When loading
      a value of a type like i20 with a size that is not an integral number of bytes, the
      result is undefined if the value was not originally written using a store of the same
      type.

***** store

        store [volatile] <ty> <value>, <ty>* <pointer>[, align <alignment>][, !nontemporal !<index>]         -> {void}
        store atomic [volatile] <ty> <value>, <ty>* <pointer> [singlethread] <ordering>, align <alignment>   -> {void}

      The 'store' instruction is used to write to memory.

      There are two arguments to the 'store' instruction: a *value* to store and an address at
      which to store it. The type of the '<pointer>' operand must be a pointer to the first
      class type of the '<value>' operand. If the store is marked as volatile, then the
      optimizer is not allowed to modify the number or order of execution of this store with
      other volatile operations.

      If the store is marked as *atomic*, it takes an extra ordering and optional *singlethread*
      argument. The acquire and acq_rel orderings aren't valid on store instructions. Atomic
      loads produce defined results when they may see multiple atomic stores. The type of the
      pointee must be an integer type whose bit width is a power of two greater than or equal
      to eight and less than or equal to a target-specific size limit. align must be explicitly
      specified on atomic stores, and the store has undefined behavior if the alignment is not
      set to a value which is at least the size in bytes of the pointee. !nontemporal does not
      have any defined semantics for atomic stores.

      The optional constant *align* argument specifies the alignment of the operation (that is,
      the alignment of the memory address). A value of 0 or an omitted "align" argument means
      that the operation has the abi alignment for the target. It is the responsibility of the
      code emitter to ensure that the alignment information is correct. Overestimating the
      alignment results in an undefined behavior. Underestimating the alignment may produce
      less efficient code. An alignment of 1 is always safe.

      The optional *!nontemporal* metadata must reference a single metatadata name <index>
      corresponding to a metadata node with one i32 entry of value 1. The existence of the
      !nontemporal metatadata on the instruction tells the optimizer and code generator that
      this load is not expected to be reused in the cache. The code generator may select
      special instructions to save cache bandwidth, such as the MOVNT instruction on x86.

      The contents of memory are updated to contain '<value>' at the location specified by the
      '<pointer>' operand. If '<value>' is of scalar type then the number of bytes written does
      not exceed the minimum number of bytes needed to hold all bits of the type. For example,
      storing an i24 writes at most three bytes. When writing a value of a type like i20 with a
      size that is not an integral number of bytes, it is unspecified what happens to the extra
      bits that do not belong to the type, but they will typically be overwritten.
***** getelementptr

        <result> = getelementptr <pty>* <ptrval>{, <ty> <idx>}*
        <result> = getelementptr inbounds <pty>* <ptrval>{, <ty> <idx>}*
        <result> = getelementptr <ptr vector> ptrval, <vector index type> idx

      The 'getelementptr' instruction is used to get the address of a subelement of an
      aggregate data structure. It performs address calculation only and does not access
      memory.

      The first argument is always a pointer or a vector of pointers, and forms the basis of
      the calculation. The remaining arguments are indices that indicate which of the elements
      of the aggregate object are indexed. The interpretation of each index is dependent on the
      type being indexed into. The first index always indexes the pointer value given as the
      first argument, the second index indexes a value of the type pointed to (not necessarily
      the value directly pointed to, since the first index can be non-zero), etc. The first
      type indexed into must be a pointer value, subsequent types can be arrays, vectors, and
      structs. Note that subsequent types being indexed into can never be pointers, since that
      would require loading the pointer before continuing calculation.

      The type of each index argument depends on the type it is indexing into. When indexing
      into a (optionally packed) structure, only i32 integer constants are allowed. When
      indexing into an array, pointer or vector, integers of any width are allowed, and they
      are not required to be constant. These integers are treated as signed values where
      relevant.

      For example, let's consider a C code fragment and how it gets compiled to LLVM:

        struct RT {
          char A;
          int B[10][20];
          char C;
        };
        struct ST {
          int X;
          double Y;
          struct RT Z;
        };

        int *foo(struct ST *s) {
          return &s[1].Z.B[5][13];
        }

      The LLVM code generated by Clang is:

        %struct.RT = type { i8, [10 x [20 x i32]], i8 }
        %struct.ST = type { i32, double, %struct.RT }

        define i32* @foo(%struct.ST* %s) nounwind uwtable readnone optsize ssp {
        entry:
          %arrayidx = getelementptr inbounds %struct.ST* %s, i64 1, i32 2, i32 1, i64 5, i64 13
          ret i32* %arrayidx
        }

      In the example above, the first index is indexing into the '%struct.ST*' type, which is a
      pointer, yielding a '%struct.ST' = '{ i32, double, %struct.RT }' type, a structure. The
      second index indexes into the third element of the structure, yielding a '%struct.RT' =
      '{ i8 , [10 x [20 x i32]], i8 }' type, another structure. The third index indexes into
      the second element of the structure, yielding a '[10 x [20 x i32]]' type, an array. The
      two dimensions of the array are subscripted into, yielding an 'i32' type. The
      'getelementptr' instruction returns a pointer to this element, thus computing a value of
      'i32*' type.

      Note that it is perfectly legal to index partially through a structure, returning a
      pointer to an inner element. Because of this, the LLVM code for the given testcase is
      equivalent to:

        define i32* @foo(%struct.ST* %s) {
          %t1 = getelementptr %struct.ST* %s, i32 1                 ; yields %struct.ST*:%t1
          %t2 = getelementptr %struct.ST* %t1, i32 0, i32 2         ; yields %struct.RT*:%t2
          %t3 = getelementptr %struct.RT* %t2, i32 0, i32 1         ; yields [10 x [20 x i32]]*:%t3
          %t4 = getelementptr [10 x [20 x i32]]* %t3, i32 0, i32 5  ; yields [20 x i32]*:%t4
          %t5 = getelementptr [20 x i32]* %t4, i32 0, i32 13        ; yields i32*:%t5
          ret i32* %t5
        }

      If the inbounds keyword is present, the result value of the getelementptr is a poison
      value if the base pointer is not an in bounds address of an allocated object, or if any
      of the addresses that would be formed by successive addition of the offsets implied by
      the indices to the base address with infinitely precise signed arithmetic are not an in
      bounds address of that allocated object. The in bounds addresses for an allocated object
      are all the addresses that point into the object, plus the address one byte past the
      end. In cases where the base is a vector of pointers the inbounds keyword applies to each
      of the computations element-wise.

      If the inbounds keyword is not present, the offsets are added to the base address with
      silently-wrapping two's complement arithmetic. If the offsets have a different width from
      the pointer, they are sign-extended or truncated to the width of the pointer. The result
      value of the getelementptr may be outside the object pointed to by the base pointer. The
      result value may not necessarily be used to access memory though, even if it happens to
      point into allocated storage. See the Pointer Aliasing Rules section for more
      information.

***** fence [singlethread] <ordering>                                                                      -> {void}
***** cmpxchg [volatile] <ty>* <pointer>, <ty> <cmp>, <ty> <new> [singlethread] <ordering>                 -> {ty}
***** atomicrmw [volatile] <operation> <ty>* <pointer>, <ty> <value> [singlethread] <ordering>             -> {ty}
*** Conversion
***** <result> = trunc, zext, sext, fptrunc, fpext <ty> <value> to <ty2>             -> ty2
***** <result> = fptoui, fptosi, uitofp, sitofp <ty> <value> to <ty2>                -> ty2
***** <result> = ptrtoint, inttoptr <ty> <value> to <ty2>                            -> ty2

      The 'ptrtoint' instruction converts the pointer or a vector of pointers value to the
      integer (or vector of integers) type ty2.

      The 'ptrtoint' instruction takes a value to cast, which must be a a value of type pointer
      or a vector of pointers, and a type to cast it to ty2, which must be an integer or a
      vector of integers type.

      The 'ptrtoint' instruction converts value to integer type ty2 by interpreting the pointer
      value as an integer and either truncating or zero extending that value to the size of the
      integer type. If value is smaller than ty2 then a zero extension is done. If value is
      larger than ty2 then a truncation is done. If they are the same size, then nothing is
      done (no-op cast) other than a type change.

***** <result> = bitcast <ty> <value> to <ty2>                                       -> ty2

      The 'bitcast' instruction converts value to type ty2 without changing any bits.

      The 'bitcast' instruction takes a value to cast, which must be a non-aggregate first
      class value, and a type to cast it to, which must also be a non-aggregate first class
      type. The bit sizes of value and the destination type, ty2, must be identical. If the
      source type is a pointer, the destination type must also be a pointer. This instruction
      supports bitwise conversion of vectors to integers and to vectors of other types (as long
      as they have the same size).

      The 'bitcast' instruction converts value to type ty2. It is always a no-op cast because
      no bits change with this conversion. The conversion is done as if the value had been
      stored to memory and read back as type ty2. Pointer (or vector of pointers) types may
      only be converted to other pointer (or vector of pointers) types with this
      instruction. To convert pointers to other types, use the inttoptr or ptrtoint
      instructions first.

*** Other
***** <result> = icmp <cond> <ty> <op1>, <op2>                                       -> {i1} or {<N x i1>}:result

      The 'icmp' instruction returns a boolean value or a vector of boolean values based on
      comparison of its two integer, integer vector, pointer, or pointer vector operands.

      The 'icmp' instruction takes three operands. The first operand is the condition code
      indicating the kind of comparison to perform. It is not a value, just a keyword. The
      possible condition code are:

        - eq :: equal
        - ne :: not equal
        - ugt :: unsigned greater than
        - uge :: unsigned greater or equal
        - ult :: unsigned less than
        - ule :: unsigned less or equal
        - sgt :: signed greater than
        - sge :: signed greater or equal
        - slt :: signed less than
        - sle :: signed less or equal

      The remaining two arguments must be integer or pointer or integer vector typed. They must
      also be identical types.

      The 'icmp' compares op1 and op2 according to the condition code given as cond. The
      comparison performed always yields either an i1 or vector of i1 result, as follows ::

        - eq :: yields true if the operands are equal, false otherwise. No sign interpretation is necessary or performed.
        - ne :: yields true if the operands are unequal, false otherwise. No sign interpretation is necessary or performed.
        - ugt :: interprets the operands as unsigned values and yields true if op1 is greater than op2.
        - uge :: interprets the operands as unsigned values and yields true if op1 is greater than or equal to op2.
        - ult :: interprets the operands as unsigned values and yields true if op1 is less than op2.
        - ule :: interprets the operands as unsigned values and yields true if op1 is less than or equal to op2.
        - sgt :: interprets the operands as signed values and yields true if op1 is greater than op2.
        - sge :: interprets the operands as signed values and yields true if op1 is greater than or equal to op2.
        - slt :: interprets the operands as signed values and yields true if op1 is less than op2.
        - sle :: interprets the operands as signed values and yields true if op1 is less than or equal to op2.

      If the operands are pointer typed, the pointer values are compared as if they were
      integers.

      If the operands are integer vectors, then they are compared element by element. The
      result is an i1 vector with the same number of elements as the values being
      compared. Otherwise, the result is an i1.

***** <result> = fcmp <cond> <ty> <op1>, <op2>                                       -> {i1} or {<N x i1>}:result

      The 'fcmp' instruction returns a boolean value or vector of boolean values based on
      comparison of its operands.

      If the operands are floating point scalars, then the result type is a boolean (i1).

      If the operands are floating point vectors, then the result type is a vector of boolean
      with the same number of elements as the operands being compared.

      The 'fcmp' instruction takes three operands. The first operand is the condition code
      indicating the kind of comparison to perform. It is not a value, just a keyword. The
      possible condition code are:

        - false :: no comparison, always returns false
        - oeq :: ordered and equal
        - ogt :: ordered and greater than
        - oge :: ordered and greater than or equal
        - olt :: ordered and less than
        - ole :: ordered and less than or equal
        - one :: ordered and not equal
        - ord :: ordered (no nans)
        - ueq :: unordered or equal
        - ugt :: unordered or greater than
        - uge :: unordered or greater than or equal
        - ult :: unordered or less than
        - ule :: unordered or less than or equal
        - une :: unordered or not equal
        - uno :: unordered (either nans)
        - true :: no comparison, always returns true

      Ordered means that neither operand is a QNAN while unordered means that either operand
      may be a QNAN.

      Each of val1 and val2 arguments must be either a floating point type or a vector of
      floating point type. They must have identical types.

      The 'fcmp' instruction compares op1 and op2 according to the condition code given as
      cond. If the operands are vectors, then the vectors are compared element by element. Each
      comparison performed always yields an i1 result, as follows:

        - false :: always yields false, regardless of operands.
        - oeq :: yields true if both operands are not a QNAN and op1 is equal to op2.
        - ogt :: yields true if both operands are not a QNAN and op1 is greater than op2.
        - oge :: yields true if both operands are not a QNAN and op1 is greater than or equal to op2.
        - olt :: yields true if both operands are not a QNAN and op1 is less than op2.
        - ole :: yields true if both operands are not a QNAN and op1 is less than or equal to op2.
        - one :: yields true if both operands are not a QNAN and op1 is not equal to op2.
        - ord :: yields true if both operands are not a QNAN.
        - ueq :: yields true if either operand is a QNAN or op1 is equal to op2.
        - ugt :: yields true if either operand is a QNAN or op1 is greater than op2.
        - uge :: yields true if either operand is a QNAN or op1 is greater than or equal to op2.
        - ult :: yields true if either operand is a QNAN or op1 is less than op2.
        - ule :: yields true if either operand is a QNAN or op1 is less than or equal to op2.
        - une :: yields true if either operand is a QNAN or op1 is not equal to op2.
        - uno :: yields true if either operand is a QNAN.
        - true :: always yields true, regardless of operands.

***** <result> = phi <ty> [ <val0>, <label0>], ...

      The 'phi' instruction is used to implement the φ node in the SSA graph representing the
      function.

      The type of the incoming values is specified with the first type field. After this, the
      'phi' instruction takes a list of pairs as arguments, with one pair for each predecessor
      basic block of the current block. Only values of first class type may be used as the
      value arguments to the PHI node. Only labels may be used as the label arguments.

      There must be no non-phi instructions between the start of a basic block and the PHI
      instructions: i.e. PHI instructions must be first in a basic block.

      For the purposes of the SSA form, the use of each incoming value is deemed to occur on
      the edge from the corresponding predecessor block to the current block (but after any
      definition of an 'invoke' instruction's return value on the same edge).

      At runtime, the 'phi' instruction logically takes on the value specified by the pair
      corresponding to the predecessor basic block that executed just prior to the current
      block.

***** <result> = select selty <cond>, <ty> <val1>, <ty> <val2>                       -> ty

      The 'select' instruction is used to choose one value based on a condition, without
      branching.

      The 'select' instruction requires an 'i1' value or a vector of 'i1' values indicating the
      condition, and two values of the same first class type. If the val1/val2 are vectors and
      the condition is a scalar, then entire vectors are selected, not individual elements.

      If the condition is an i1 and it evaluates to 1, the instruction returns the first value
      argument; otherwise, it returns the second value argument.

      If the condition is a vector of i1, then the value arguments must be vectors of the same
      size, and the selection is done element by element.

***** <result> = [tail] call [cconv] [ret attrs] <ty> [<fnty>*] <fnptrval>(<function args>) [fn attrs]  -> ty

      The 'call' instruction represents a simple function call.

      This instruction requires several arguments:

        - The optional "tail" marker indicates that the callee function does not access any
          allocas or varargs in the caller. Note that calls may be marked "tail" even if they
          do not occur before a ret instruction. If the "tail" marker is present, the function
          call is eligible for tail call optimization, but might not in fact be optimized into
          a jump. The code generator may optimize calls marked "tail" with either 1) automatic
          sibling call optimization when the caller and callee have matching signatures, or 2)
          forced tail call optimization when the following extra requirements are met:
            - Caller and callee both have the calling convention fastcc.
            - The call is in tail position (ret immediately follows call and ret uses value of
              call or is void).
            - Option -tailcallopt is enabled, or llvm::GuaranteedTailCallOpt is true.
            - Platform specific constraints are met.
        - The optional "cconv" marker indicates which calling convention the call should
          use. If none is specified, the call defaults to using C calling conventions. The
          calling convention of the call must match the calling convention of the target
          function, or else the behavior is undefined.
        - The optional Parameter Attributes list for return values. Only 'zeroext', 'signext',
          and 'inreg' attributes are valid here.
        - 'ty': the type of the call instruction itself which is also the type of the return
          value. Functions that return no value are marked void.
        - 'fnty': shall be the signature of the pointer to function value being invoked. The
          argument types must match the types implied by this signature. This type can be
          omitted if the function is not varargs and if the function type does not return a
          pointer to a function.
        - 'fnptrval': An LLVM value containing a pointer to a function to be invoked. In most
          cases, this is a direct function invocation, but indirect calls are just as possible,
          calling an arbitrary pointer to function value.
        - 'function args': argument list whose types match the function signature argument
          types and parameter attributes. All arguments must be of first class type. If the
          function signature indicates the function accepts a variable number of arguments, the
          extra arguments can be specified.
        - The optional function attributes list. Only 'noreturn', 'nounwind', 'readonly' and
          'readnone' attributes are valid here.

      The 'call' instruction is used to cause control flow to transfer to a specified function,
      with its incoming arguments bound to the specified values. Upon a 'ret' instruction in
      the called function, control flow continues with the instruction after the function call,
      and the return value of the function is bound to the result argument.

***** <resultval> = va_arg <va_list*> <arglist>, <argty>

      The 'va_arg' instruction is used to access arguments passed through the "variable
      argument" area of a function call. It is used to implement the va_arg macro in C.

      This instruction takes a va_list* value and the type of the argument. It returns a value
      of the specified argument type and increments the va_list to point to the next
      argument. The actual type of va_list is target specific.

      The 'va_arg' instruction loads an argument of the specified type from the specified
      va_list and causes the va_list to point to the next argument. For more information, see
      the variable argument handling Intrinsic Functions.

      It is legal for this instruction to be called in a function which does not take a
      variable number of arguments, for example, the vfprintf function.

      va_arg is an LLVM instruction instead of an intrinsic function because it takes a type as
      an argument.

***** <resultval> = landingpad <resultty> personality <type> <pers_fn> (<clause>+ | cleanup <clause>*)

        <clause> := catch <type> <value>
        <clause> := filter <array constant type> <array constant>

      The 'landingpad' instruction is used by LLVM's exception handling system to specify that
      a basic block is a landing pad — one where the exception lands, and corresponds to the
      code found in the catch portion of a try/catch sequence. It defines values supplied by
      the personality function (pers_fn) upon re-entry to the function. The resultval has the
      type resultty.

      This instruction takes a pers_fn value. This is the personality function associated with
      the unwinding mechanism. The optional cleanup flag indicates that the landing pad block
      is a cleanup.

      A clause begins with the clause type — catch or filter — and contains the global variable
      representing the "type" that may be caught or filtered respectively. Unlike the catch
      clause, the filter clause takes an array constant as its argument. Use "[0 x i8**] undef"
      for a filter which cannot throw. The 'landingpad' instruction must contain at least one
      clause or the cleanup flag.

      The 'landingpad' instruction defines the values which are set by the personality function
      (pers_fn) upon re-entry to the function, and therefore the "result type" of the
      landingpad instruction. As with calling conventions, how the personality function results
      are represented in LLVM IR is target specific.

      The clauses are applied in order from top to bottom. If two landingpad instructions are
      merged together through inlining, the clauses from the calling function are appended to
      the list of clauses. When the call stack is being unwound due to an exception being
      thrown, the exception is compared against each clause in turn. If it doesn't match any of
      the clauses, and the cleanup flag is not set, then unwinding continues further up the
      call stack.

      The landingpad instruction has several restrictions:

        - A landing pad block is a basic block which is the unwind destination of an 'invoke' instruction.
        - A landing pad block must have a 'landingpad' instruction as its first non-PHI instruction.
        - There can be only one 'landingpad' instruction within the landing pad block.
        - A basic block that is not a landing pad block may not include a 'landingpad' instruction.
        - All 'landingpad' instructions in a function must have the same personality function.

* Intrinsic functions
*** Convention:
***** USE: "call", "invoke" instructions
***** can be independently defined for different types
*** Variable arguments: "va_arg" insn, along with:

    Variable argument support is defined in LLVM with the va_arg instruction and these three
    intrinsic functions. These functions are related to the similarly named macros defined in
    the <stdarg.h> header file.

    All of these functions operate on arguments that use a target-specific value type
    "va_list". The LLVM assembly language reference manual does not define what this type is,
    so all transformations should be prepared to handle these functions regardless of the type
    used.

    This example shows how the va_arg instruction and the variable argument handling intrinsic
    functions are used.

#+begin_src asm
      define i32 @test(i32 %X, ...) {
        ; Initialize variable argument processing
        %ap = alloca i8*
        %ap2 = bitcast i8** %ap to i8*
        call void @llvm.va_start(i8* %ap2)

        ; Read a single integer argument
        %tmp = va_arg i8** %ap, i32

        ; Demonstrate usage of llvm.va_copy and llvm.va_end
        %aq = alloca i8*
        %aq2 = bitcast i8** %aq to i8*
        call void @llvm.va_copy(i8* %aq2, i8* %ap2)
        call void @llvm.va_end(i8* %aq2)

        ; Stop processing of arguments.
        call void @llvm.va_end(i8* %ap2)
        ret i32 %tmp
      }

      declare void @llvm.va_start(i8*)
      declare void @llvm.va_copy(i8*, i8*)
      declare void @llvm.va_end(i8*)
#+end_src

***** declare void %llvm.va_start(i8* <arglist>)

      The *llvm.va_start* intrinsic initializes *<arglist> for subsequent use by va_arg.

      The argument is a pointer to a va_list element to initialize.

      The *llvm.va_start* intrinsic works just like the va_start macro available in C. In a
      target-dependent way, it initializes the va_list element to which the argument points, so
      that the next call to va_arg will produce the first variable argument passed to the
      function. Unlike the C va_start macro, this intrinsic does not need to know the last
      argument of the function as the compiler can figure that out.

***** declare void @llvm.va_end(i8* <arglist>)

      The *llvm.va_end* intrinsic destroys *<arglist>, which has been initialized previously
      with llvm.va_start or llvm.va_copy.

      The argument is a pointer to a va_list to destroy.

      The *llvm.va_end* intrinsic works just like the va_end macro available in C. In a
      target-dependent way, it destroys the va_list element to which the argument points. Calls
      to llvm.va_start and llvm.va_copy must be matched exactly with calls to llvm.va_end.

***** void @llvm.va_copy(i8* <destarglist>, i8* <srcarglist>)

      The *llvm.va_copy* intrinsic copies the current argument position from the source
      argument list to the destination argument list.

      The first argument is a pointer to a va_list element to initialize. The second argument
      is a pointer to a va_list element to copy from.

      The *llvm.va_copy* intrinsic works just like the va_copy macro available in C. In a
      target-dependent way, it copies the source va_list element into the destination va_list
      element. This intrinsic is necessary because the llvm.va_start intrinsic may be
      arbitrarily complex and require, for example, memory allocation.

*** Accurate GC
***** declare void @llvm.gcroot(i8** %ptrloc, i8* %metadata)
***** declare i8* @llvm.gcread(i8* %ObjPtr, i8** %Ptr)
***** declare void @llvm.gcwrite(i8* %P1, i8* %Obj, i8** %P2)
*** Code generator
***** declare i8* @llvm.returnaddress(i32 <level>)
***** declare i8* @llvm.frameaddress(i32 <level>)
***** declare i8* @llvm.stacksave()
***** declare void @llvm.stackrestore(i8* %ptr)
***** declare void @llvm.prefetch(i8* <address>, i32 <rw>, i32 <locality>, i32 <cache type>)
***** declare void @llvm.pcmarker(i32 <id>)
***** declare i64 @llvm.readcyclecounter()
*** Standard C Library Intrinsics
***** memcpy
******* declare void @llvm.memcpy.p0i8.p0i8.i32(i8* <dest>, i8* <src>, i32 <len>, i32 <align>, i1 <isvolatile>)
******* declare void @llvm.memcpy.p0i8.p0i8.i64(i8* <dest>, i8* <src>, i64 <len>, i32 <align>, i1 <isvolatile>)
***** memmove
******* declare void @llvm.memmove.p0i8.p0i8.i32(i8* <dest>, i8* <src>, i32 <len>, i32 <align>, i1 <isvolatile>)
******* declare void @llvm.memmove.p0i8.p0i8.i64(i8* <dest>, i8* <src>, i64 <len>, i32 <align>, i1 <isvolatile>)
***** memset
******* declare void @llvm.memset.p0i8.i32(i8* <dest>, i8 <val>, i32 <len>, i32 <align>, i1 <isvolatile>)
******* declare void @llvm.memset.p0i8.i64(i8* <dest>, i8 <val>, i64 <len>, i32 <align>, i1 <isvolatile>)
***** sqrt
******* declare float     @llvm.sqrt.f32(float %Val)
******* declare double    @llvm.sqrt.f64(double %Val)
******* declare x86_fp80  @llvm.sqrt.f80(x86_fp80 %Val)
******* declare fp128     @llvm.sqrt.f128(fp128 %Val)
******* declare ppc_fp128 @llvm.sqrt.ppcf128(ppc_fp128 %Val)
***** powi
******* declare float     @llvm.powi.f32(float  %Val, i32 %power)
******* declare double    @llvm.powi.f64(double %Val, i32 %power)
******* declare x86_fp80  @llvm.powi.f80(x86_fp80  %Val, i32 %power)
******* declare fp128     @llvm.powi.f128(fp128 %Val, i32 %power)
******* declare ppc_fp128 @llvm.powi.ppcf128(ppc_fp128  %Val, i32 %power)
***** sin
******* declare float     @llvm.sin.f32(float  %Val)
******* declare double    @llvm.sin.f64(double %Val)
******* declare x86_fp80  @llvm.sin.f80(x86_fp80  %Val)
******* declare fp128     @llvm.sin.f128(fp128 %Val)
******* declare ppc_fp128 @llvm.sin.ppcf128(ppc_fp128  %Val)
***** cos
******* declare float     @llvm.cos.f32(float  %Val)
******* declare double    @llvm.cos.f64(double %Val)
******* declare x86_fp80  @llvm.cos.f80(x86_fp80  %Val)
******* declare fp128     @llvm.cos.f128(fp128 %Val)
******* declare ppc_fp128 @llvm.cos.ppcf128(ppc_fp128  %Val)
***** pow
******* declare float     @llvm.pow.f32(float  %Val, float %Power)
******* declare double    @llvm.pow.f64(double %Val, double %Power)
******* declare x86_fp80  @llvm.pow.f80(x86_fp80  %Val, x86_fp80 %Power)
******* declare fp128     @llvm.pow.f128(fp128 %Val, fp128 %Power)
******* declare ppc_fp128 @llvm.pow.ppcf128(ppc_fp128  %Val, ppc_fp128 Power)
***** exp
******* declare float     @llvm.exp.f32(float  %Val)
******* declare double    @llvm.exp.f64(double %Val)
******* declare x86_fp80  @llvm.exp.f80(x86_fp80  %Val)
******* declare fp128     @llvm.exp.f128(fp128 %Val)
******* declare ppc_fp128 @llvm.exp.ppcf128(ppc_fp128  %Val)
***** log
******* declare float     @llvm.log.f32(float  %Val)
******* declare double    @llvm.log.f64(double %Val)
******* declare x86_fp80  @llvm.log.f80(x86_fp80  %Val)
******* declare fp128     @llvm.log.f128(fp128 %Val)
******* declare ppc_fp128 @llvm.log.ppcf128(ppc_fp128  %Val)
***** fma
******* declare float     @llvm.fma.f32(float  %a, float  %b, float  %c)
******* declare double    @llvm.fma.f64(double %a, double %b, double %c)
******* declare x86_fp80  @llvm.fma.f80(x86_fp80 %a, x86_fp80 %b, x86_fp80 %c)
******* declare fp128     @llvm.fma.f128(fp128 %a, fp128 %b, fp128 %c)
******* declare ppc_fp128 @llvm.fma.ppcf128(ppc_fp128 %a, ppc_fp128 %b, ppc_fp128 %c)
***** fabs
******* declare float     @llvm.fabs.f32(float  %Val)
******* declare double    @llvm.fabs.f64(double %Val)
******* declare x86_fp80  @llvm.fabs.f80(x86_fp80  %Val)
******* declare fp128     @llvm.fabs.f128(fp128 %Val)
******* declare ppc_fp128 @llvm.fabs.ppcf128(ppc_fp128  %Val)
***** floor
******* declare float     @llvm.floor.f32(float  %Val)
******* declare double    @llvm.floor.f64(double %Val)
******* declare x86_fp80  @llvm.floor.f80(x86_fp80  %Val)
******* declare fp128     @llvm.floor.f128(fp128 %Val)
******* declare ppc_fp128 @llvm.floor.ppcf128(ppc_fp128  %Val)
*** Bit manipulation
***** bswap
******* declare i16 @llvm.bswap.i16(i16 <id>)
******* declare i32 @llvm.bswap.i32(i32 <id>)
******* declare i64 @llvm.bswap.i64(i64 <id>)
***** ctpop
******* declare i8 @llvm.ctpop.i8(i8  <src>)
******* declare i16 @llvm.ctpop.i16(i16 <src>)
******* declare i32 @llvm.ctpop.i32(i32 <src>)
******* declare i64 @llvm.ctpop.i64(i64 <src>)
******* declare i256 @llvm.ctpop.i256(i256 <src>)
******* declare <2 x i32> @llvm.ctpop.v2i32(<2 x i32> <src>)
***** ctlz
******* declare i8   @llvm.ctlz.i8  (i8   <src>, i1 <is_zero_undef>)
******* declare i16  @llvm.ctlz.i16 (i16  <src>, i1 <is_zero_undef>)
******* declare i32  @llvm.ctlz.i32 (i32  <src>, i1 <is_zero_undef>)
******* declare i64  @llvm.ctlz.i64 (i64  <src>, i1 <is_zero_undef>)
******* declare i256 @llvm.ctlz.i256(i256 <src>, i1 <is_zero_undef>)
******* declase <2 x i32> @llvm.ctlz.v2i32(<2 x i32> <src>, i1 <is_zero_undef>)
***** cttz
******* declare i8   @llvm.cttz.i8  (i8   <src>, i1 <is_zero_undef>)
******* declare i16  @llvm.cttz.i16 (i16  <src>, i1 <is_zero_undef>)
******* declare i32  @llvm.cttz.i32 (i32  <src>, i1 <is_zero_undef>)
******* declare i64  @llvm.cttz.i64 (i64  <src>, i1 <is_zero_undef>)
******* declare i256 @llvm.cttz.i256(i256 <src>, i1 <is_zero_undef>)
******* declase <2 x i32> @llvm.cttz.v2i32(<2 x i32> <src>, i1 <is_zero_undef>)
*** Arithmetic with overflow
***** sadd
******* declare {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b)
******* declare {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b)
******* declare {i64, i1} @llvm.sadd.with.overflow.i64(i64 %a, i64 %b)
***** uadd
******* declare {i16, i1} @llvm.uadd.with.overflow.i16(i16 %a, i16 %b)
******* declare {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b)
******* declare {i64, i1} @llvm.uadd.with.overflow.i64(i64 %a, i64 %b)
***** ssub
******* declare {i16, i1} @llvm.ssub.with.overflow.i16(i16 %a, i16 %b)
******* declare {i32, i1} @llvm.ssub.with.overflow.i32(i32 %a, i32 %b)
******* declare {i64, i1} @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)
***** usub
******* declare {i16, i1} @llvm.usub.with.overflow.i16(i16 %a, i16 %b)
******* declare {i32, i1} @llvm.usub.with.overflow.i32(i32 %a, i32 %b)
******* declare {i64, i1} @llvm.usub.with.overflow.i64(i64 %a, i64 %b)
***** smul
******* declare {i16, i1} @llvm.smul.with.overflow.i16(i16 %a, i16 %b)
******* declare {i32, i1} @llvm.smul.with.overflow.i32(i32 %a, i32 %b)
******* declare {i64, i1} @llvm.smul.with.overflow.i64(i64 %a, i64 %b)
***** umul
******* declare {i16, i1} @llvm.umul.with.overflow.i16(i16 %a, i16 %b)
******* declare {i32, i1} @llvm.umul.with.overflow.i32(i32 %a, i32 %b)
******* declare {i64, i1} @llvm.umul.with.overflow.i64(i64 %a, i64 %b)
*** Specialized arithmetic
***** fmuladd
******* declare float @llvm.fmuladd.f32(float %a, float %b, float %c)
******* declare double @llvm.fmuladd.f64(double %a, double %b, double %c)
*** Half Precision Floating Point
***** declare i16 @llvm.convert.to.fp16(f32 %a)
***** declare f32 @llvm.convert.from.fp16(i16 %a)
*** Debugger: llvm.dbg
*** Exception handling: llvm.eh
*** Trampoline:
***** declare void @llvm.init.trampoline(i8* <tramp>, i8* <func>, i8* <nval>)

      This fills the memory pointed to by tramp with executable code, turning it into a
      trampoline.

***** declare i8* @llvm.adjust.trampoline(i8* <tramp>)

      This performs any required machine-specific adjustment to the address of a trampoline (passed as tramp).

*** Memory use markers
***** declare void @llvm.lifetime.start OR @llvm.lifetime.end(i64 <size>, i8* nocapture <ptr>)

      The 'llvm.lifetime.start' intrinsic specifies the start of a memory object's lifetime.
      The 'llvm.lifetime.end intrinsic specifies the end of a memory object's lifetime.

***** declare {}* @llvm.invariant.start(i64 <size>, i8* nocapture <ptr>)

      The 'llvm.invariant.start' intrinsic specifies that the contents of a memory object will not change.

***** declare void @llvm.invariant.end({}* <start>, i64 <size>, i8* nocapture <ptr>)

      The 'llvm.invariant.end' intrinsic specifies that the contents of a memory object are mutable.

*** General intrinsics
***** declare void @llvm.var.annotation(i8* <val>, i8* <str>, i8* <str>, i32  <int>)
***** llvm.annotation
******* declare i8 @llvm.annotation.i8(i8 <val>, i8* <str>, i8* <str>, i32  <int>)
******* declare i16 @llvm.annotation.i16(i16 <val>, i8* <str>, i8* <str>, i32  <int>)
******* declare i32 @llvm.annotation.i32(i32 <val>, i8* <str>, i8* <str>, i32  <int>)
******* declare i64 @llvm.annotation.i64(i64 <val>, i8* <str>, i8* <str>, i32  <int>)
******* declare i256 @llvm.annotation.i256(i256 <val>, i8* <str>, i8* <str>, i32  <int>)
***** declare void @llvm.trap() noreturn nounwind
***** declare void @llvm.debugtrap() nounwind
***** declare void @llvm.stackprotector(i8* <guard>, i8** <slot>)
***** llvm.objectsize
******* declare i32 @llvm.objectsize.i32(i8* <object>, i1 <min>)
******* declare i64 @llvm.objectsize.i64(i8* <object>, i1 <min>)
***** llvm.expect: most probable value 
******* declare i32 @llvm.expect.i32(i32 <val>, i32 <expected_val>)
******* declare i64 @llvm.expect.i64(i64 <val>, i64 <expected_val>)
***** declare void @llvm.donothing() nounwind readnone


